## Memory Segmentation
---
* Text segment
	* code segment
	* location of instructions of the program
	* the execution of instructions is not linear
	* read-only
		* prevent from modifying code -> alert -> kill
		* can be shared among different copies, allowing multiple
		  executions of the program at the same time
	* fixed size
* Data and bss segments
	* store global and static variables (data)
	* uninitialized counterparts (bss)
	* writable
	* fixed size
* Heap segment
	* segment of memory a programmer can directly control
	* variable size
	* is managed bu allocator and deallocator algorithms
	* will grow and shrink depending on how much memory is reserved for use
* Stack segment
	* variable size
	* used as atemporary scratch pad
	* to store local function variables and context during function calls
	* used to remember all of the passed variables, the location that RIP
	  should return to after the function is finished, local variables used
	  by function in stack frame
	* the stack contains many stack frames
	* stack frame contain
		- parameters of the function
		- local vriables
		- two pointers
			* Saved frame pointer
				- used to restore RBP to its previous value
			* Return address
				- used to restore RIP to the next instruction
				  found after the function call

## File Permissions
* S_IRUSR   Give the file read permission for the user (owner)
* S_IWUSR   Write permission
* S_IXUSR   Execute permission
* S_IRGRP   Give the file read permission for the group
* S_IWGRP   Write permission
* S_IXGRP   Execute permission
* S_IROTH   Give the file read permission for other (anyone)
* S_IWOTH   Write permission
* S_IXOTH   Execute permission

## Pointers
* Contains a memory address
* Is given a data type that describes where it points
* Usually used for variables
* Also can be used for functions
