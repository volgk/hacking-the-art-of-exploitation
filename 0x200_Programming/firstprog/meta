1. See the binary file:
	$ objdump -D a.out | grep -A20 main.: 
	0000000000001135 <main>:
	1135:       55                      push   %rbp
	1136:       48 89 e5                mov    %rsp,%rbp
	1139:       48 83 ec 10             sub    $0x10,%rsp
	113d:       c7 45 fc 00 00 00 00    movl   $0x0,-0x4(%rbp)
	1144:       eb 10                   jmp    1156 <main+0x21>
	1146:       48 8d 3d b7 0e 00 00    lea    0xeb7(%rip),%rdi        #
	2004 <_IO_stdin_used+0x4>
	114d:       e8 de fe ff ff          callq  1030 <puts@plt>
	1152:       83 45 fc 01             addl   $0x1,-0x4(%rbp)
	1156:       83 7d fc 09             cmpl   $0x9,-0x4(%rbp)
	115a:       7e ea                   jle    1146 <main+0x11>
	115c:       b8 00 00 00 00          mov    $0x0,%eax
	1161:       c9                      leaveq
	1162:       c3                      retq
	1163:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
	116a:       00 00 00
	116d:       0f 1f 00		    nopl   (%rax)
	0000000000001170 <__libc_csu_init>:
	1170:       41 57		    push   %r15
	1172:       49 89 d7		    mov    %rdx,%r15

2. Recognize the AT&T syntax:
	* the cacophony of % and & symbols prefixing everything

3. Intel syntax:
	$ objdump -M intel -D a.out | grep -A20 main.:
	0000000000001135 <main>:
	1135:       55                      push   rbp
	1136:       48 89 e5                mov    rbp,rsp
	1139:       48 83 ec 10             sub    rsp,0x10
	113d:       c7 45 fc 00 00 00 00    mov    DWORD PTR [rbp-0x4],0x0
	1144:       eb 10                   jmp    1156 <main+0x21>
	1146:       48 8d 3d b7 0e 00 00    lea    rdi,[rip+0xeb7]        #2004 <_IO_stdin_used+0x4>
	114d:       e8 de fe ff ff          call   1030 <puts@plt>
	1152:       83 45 fc 01             add    DWORD PTR [rbp-0x4],0x1
	1156:       83 7d fc 09             cmp    DWORD PTR [rbp-0x4],0x9
        115a:       7e ea                   jle    1146 <main+0x11>
        115c:       b8 00 00 00 00          mov    eax,0x0
	1161:       c9                      leave
	1162:       c3                      ret
	1163:       66 2e 0f 1f 84 00 00    nop    WORD PTR cs:[rax+rax*1+0x0]
	116a:       00 00 00
	116d:       0f 1f 00		    nop    DWORD PTR [rax]	0000000000001170 <__libc_csu_init>:
	1170:       41 57		    push   r15
	1172:       49 89 d7		    mov    r15,rdx

4. Debugging with GDB:
	$ gdb -q a.out
	Reading symbols from a.out...
	(No debugging symbols found in a.out)
	(gdb) break main
	Breakpoint 1 at 0x1139
	(gdb) run
	Starting program: /home/volk/Projects/goodocs/hacking-book/firstprog/a.out

	Breakpoint 1, 0x0000555555555139 in main ()
	(gdb) info registers
	rax            0x555555555135      93824992235829
	rbx            0x0                 0
	rcx            0x7ffff7fb3718      140737353824024
	rdx            0x7fffffffe0a8      140737488347304
	rsi            0x7fffffffe098      140737488347288
	rdi            0x1                 1
	rbp            0x7fffffffdfb0      0x7fffffffdfb0
	rsp            0x7fffffffdfb0      0x7fffffffdfb0
	r8             0x7ffff7fb4d80      140737353829760
	r9             0x7ffff7fb4d80      140737353829760
	r10            0x2                 2
	r11            0x3                 3
	r12            0x555555555050      93824992235600
	r13            0x7fffffffe090      140737488347280
	r14            0x0                 0
	r15            0x0                 0
	rip            0x555555555139      0x555555555139 <main+4>
	eflags         0x246               [ PF ZF IF ]
	cs             0x33                51
	ss             0x2b                43
	ds             0x0                 0
	es             0x0                 0
	fs             0x0                 0
	gs             0x0                 0
	(gdb) quit
	A debugging session is active.

	        Inferior 1 [process 27011] will be killed.
		Quit anyway? (y or n) y

	* 'rax', 'rbx', 'rcx', 'rdx' are General Purpose Registers
	  Called 'Accumulator', 'Base', 'Counter', 'Data'
	  Temporary variables for the CPU
	* 'rsi', 'rdi', 'rbp', 'rsp' are pointers and indexes
	  Called 'Source index', 'Destination index', 'Base pointer',
		 'Stack pointer'
	* 'rip' Instruction Pointer
	  The processor reads each instruction using 'rip'
	* The rest are EFLAGS
	  Used for comparations and memory segmentations
5. Assembly language
	* Configure the tools:
		$ gdb -q 
		(gdb) set disassembly intel
		(gdb) quit
		$ echo "set disassembly intel" > ~/.gdbinit
		$ cat ~/.gdbinit
		set disassembly intel

	* If compile with -g argument:
		$ gcc -g firstprog.c
		$ ls -l a.out
		$ gdb -q a.out
		(gdb) list
		1       # include <stdio.h>
		2       int main()
		3       {
		4               int i;
		5               for (i=0; i<10; i++)
		6               // Loop 10 times.
		7               {
		8                       puts("Hello, world!\n");
		9                       // Put the string to the output.
		10              }
		
		(gdb) disassemble main
		Dump of assembler code for function main:
			0x0000000000001135 <+0>:     push   rbp
			0x0000000000001136 <+1>:     mov    rbp,rsp
			0x0000000000001139 <+4>:     sub    rsp,0x10
			0x000000000000113d <+8>:     mov    DWORD PTR [rbp-0x4],0x0
			0x0000000000001144 <+15>:    jmp    0x1156 <main+33>
			0x0000000000001146 <+17>:    lea    rdi,[rip+0xeb7]        # 0x2004
			0x000000000000114d <+24>:    call   0x1030 <puts@plt>
		        0x0000000000001152 <+29>:    add    DWORD PTR [rbp-0x4],0x1
			0x0000000000001156 <+33>:    cmp    DWORD PTR [rbp-0x4],0x9
			0x000000000000115a <+37>:    jle    0x1146 <main+17>
			0x000000000000115c <+39>:    mov    eax,0x0
			0x0000000000001161 <+44>:    leave
			0x0000000000001162 <+45>:    ret
		End of assembler dump.
		
		(gdb) break main
		Breakpoint 1 at 0x113d: file firstprog.c, line 5.

		(gdb) run
		Starting program: /home/volk/Projects/goodocs/hacking-book/firstprog/a.out

		Breakpoint 1, main () at firstprog.c:5
		5               for (i=0; i<10; i++)

		(gdb) info register rip
		rip            0x55555555513d      0x55555555513d <main+8>

		// Display in octal
		(gdb) x/o 0x55555555513d
		0x55555555513d <main+8>:        077042707
		
		// Display in hexadecimal
		(gdb) x/x $rip
		0x55555555513d <main+8>:        0x00fc45c7

		// Display in unsigned, standard base-10 decimal
		(gdb) x/u $rip
		0x55555555513d <main+8>:        16532935

		// Display in binary
		(gdb) x/t $rip
		0x55555555513d <main+8>:        00000000111111000100010111000111

		// A number can also be prepended to the format of the examine
		   command to examine multiple units at the target address
		(gdb) x/2x $rip
		0x55555555513d <main+8>:        0x00fc45c7      0xeb000000

		(gdb) x/12x $rip
		0x55555555513d <main+8>:        0x00fc45c7      0xeb000000      0x3d8d4810	0x00000eb7
		0x55555555514d <main+24>:       0xfffedee8      0xfc4583ff      0xfc7d8301	0xb8ea7e09
		0x55555555515d <main+40>:       0x00000000      0x2e66c3c9      0x00841f0f	0x00000000

	* word - A default size of a single unit is four-byte
		
		// A single bite
		(gdb) x/8xb $rip
		0x55555555513d <main+8>:        0xc7    0x45    0xfc    0x00    0x00    0x00    0x00    0xeb

		// A halfword, two bytes in size
		(gdb) x/8xh $rip
		0x55555555513d <main+8>:        0x45c7  0x00fc  0x0000  0xeb00  0x4810  0x3d8d  0x0eb7  0x0000
		
		// A word, four bytes in size
		(gdb) x/8xw $rip
		0x55555555513d <main+8>:        0x00fc45c7      0xeb000000      0x3d8d4810  0x00000eb7
		0x55555555514d <main+24>:       0xfffedee8      0xfc4583ff      0xfc7d8301		0xb8ea7e09

		// A giant, eight bytes in size
		(gdb) x/8xg $rip
		0x55555555513d <main+8>:        0xeb00000000fc45c7      0x00000eb73d8d4810
		0x55555555514d <main+24>:       0xfc4583fffffedee8      0xb8ea7e09fc7d8301
		0x55555555515d <main+40>:       0x2e66c3c900000000      0x0000000000841f0f
		0x55555555516d: 0xd789495741001f0f      0x415541f689495641






